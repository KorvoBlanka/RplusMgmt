#!/usr/bin/env perl

use FindBin;
use lib "$FindBin::Bin/../../lib";

use Rplus::Modern;

use Rplus::Model::AddressObject;
use Rplus::Model::AddressObject::Manager;
use Rplus::Model::Media;
use Rplus::Model::Media::Manager;
use Rplus::Model::Mediator;
use Rplus::Model::Mediator::Manager;
use Rplus::Model::MediaImportHistory;
use Rplus::Model::MediaImportHistory::Manager;
use Rplus::Model::Realty;
use Rplus::Model::Realty::Manager;

use Rplus::Util::PhoneNum;
use Rplus::Util::Realty;
use Rplus::Util::Mediator qw(add_mediator);
use Rplus::Util::StatImport;

use DateTime::Format::Strptime;
use File::Basename;
use Text::Trim;
use JSON;
use Mojo::UserAgent;
use Data::Dumper;
use File::Touch;

no warnings 'experimental';

my $app_config = Rplus::Util::Config::get_config();
my $config = Rplus::Util::Config::get_config('import.conf');

my $barahla_config = $config->{khv_barahla};
my $main_url = $barahla_config->{main_url};

my $all_url_list = $barahla_config -> {source_list};

my $lock_file = '/var/tmp/barahla_s_lock';

my $MEDIA = Rplus::Model::Media::Manager->get_objects(query => [type => 'import', code => 'barahlo', delete_date => undef])->[0];
exit unless $MEDIA;
my $META = from_json($MEDIA->metadata);

my $ua = Mojo::UserAgent->new;
$ua->max_redirects(4);

my %date_map = ();
my $parser = DateTime::Format::Strptime->new( pattern => '%Y-%m-%d %H:%M' ); #Шаблон времени Год-месяц-день Часы:минуты

my $stat_count = {
                  count_all_ad => 0,  #найдённых ссылок
                  count_new_ad => 0,   #новых объектов
                  count_update_ad => 0 ,  #обновленных объектов
                  count_update_link => 0 ,  #обновленных ссылок
                  count_error_ad => 0 ,   #кол-во ошибок
                  url_list => [], #ссылки с ошибками
                  error_list => [], #текст с ошибками
};
unless (_import_in_progress()) { #Если импортирование не в процессе
      _lock();
      import_barahlo();
      _unlock();
}

sub _lock {
      my $temp=touch($lock_file); # создать файл
}

sub _unlock {
      unlink $lock_file; # удалить файл
}

sub _import_in_progress {
      $stat_count->{date_start} = DateTime->now(time_zone => "local");
      if (-e $lock_file) { #существует ли файл?
          my $mtime = ( stat $lock_file )[9]; #получение статуса о файле 9-время последнего изменения о файле
          my $current_time = time; #получение текущего времени
          my $diff = $current_time - $mtime; #вычисление разницы между текущим и временем изменения файла
          if ($diff < 6 * 60 * 60) { #если разница меньше 21600 секунд (6 часов)
              return 1; #возвращаем true
          }
      }
      return 0;
}

sub import_barahlo {
  my @url_list;
  foreach (@$all_url_list){
      @url_list = get_url_list($main_url . $_->{url}, $_->{pages}); # наполняем массив списком URL
      process_url_list(\@url_list, $_->{type}, $_->{offer_type});
  }
  Rplus::Util::StatImport::save_import_statistic($MEDIA->id, $stat_count);
}

sub get_url_list {
    my ($main_page, $page_count) = @_;
    my @url_list;

    for(my $i = 1; $i <= $page_count; $i ++) {
        sleep 2;
        my $dom = $ua->get($main_page . '?page=' . $i)->res->dom; #изьятие DOM страницы
        $dom->find('a[class=" ads-title-link"]')->each (sub {
            my $item_id; #id объявления
            my $item_url = $_->{href}; #ссылка на объявление
            if ($item_url =~ /\/(\d+).html/) {
                $item_id = $1;
            }
            my $add_date = parse_data ($_->parent->parent->parent->parent->find('td[class="ob_descr"]')->first->at('table')->at('tbody')->
                              at('tr')->at('td')->next->find('p')->last->previous->text);
            $date_map{$item_id} = $add_date; #сохраняем дату в глоб.переменную используя ID-Data
            my $eid = make_eid($item_id, $add_date); #создаём уник.ID в формате ID_DATA
            if (Rplus::Model::MediaImportHistory::Manager->get_objects_count(query => [media_id => $MEDIA->id, media_num => $eid])) {
                  say 'was processed already';
            } else {
                  say $item_url;
                  if ($item_url ~~ @url_list) { #Проверяет есть ли этот объект в массиве
                      say 'wtf?!';
                  } else {
                      push(@url_list, $item_url); #сохраняем в массив URL ссылку

                  }
            }
        });
    }
    $stat_count->{count_all_ad}+=scalar @url_list;
    return reverse @url_list;  #reverse - переворачивает массив
}

sub process_url_list {
    my ($url_list_ref, $type, $offer_type) = @_;

    for my $item_url (reverse @$url_list_ref) {

        my $item_id = basename($item_url); # извлечение имени объекта из адреса
        $item_id=~s/\.html//;
        my $dt = $date_map{$item_id};
        my $eid = make_eid($item_id, $dt);# создание уникального идентификатора
        say 'processing ' . $item_url;
        my $data = {
            source_media_id => $MEDIA->id,
            source_url => $item_url,
            type_code => $type,
            offer_type_code => $offer_type,
            add_date => $dt->datetime() . '+10',
        };
        #sleep 2;
        eval {
            my $dom = get_res($item_url, [])->dom; #Изьятия Dom страницы объекта
            if ($dom) { #Если Dom не пустой
                eval { # попробовать выполнить
                    parse_adv($dom, $data);
                } or do {
                    say "ERROR of Parsing: ".$@;  # сообщение об ошибке
                }
            }

            my $id;
            {
                eval {
                    $id = Rplus::Util::Realty::put_object($data, $app_config, $stat_count);
                } or do {
                    say "Error of put object:".$@;
                }
            }
            # Сохраним историю
            if ($id && !Rplus::Model::MediaImportHistory::Manager->get_objects_count(query => [media_id => $MEDIA->id, media_num => $eid])) {
                Rplus::Model::MediaImportHistory->new(media_id => $MEDIA->id, media_num => $eid, media_text => $main_url . $item_url, realty_id => $id)->save;
            }

        } or do {
          if($@){
            say "Err:".$@;
          }
        }
    }
}

sub set_address {
    my ($data, $addr) = @_;

    $data->{address} = $addr;
}

sub parse_data {
    my @data=@_;
    my $ret_data;

    my $dt_now = DateTime->now(time_zone => "+1000"); # сохраняем текущее время с учетом временной зоны +10 (Хабаровск)
    my $year = $dt_now->year(); # Текущий год
    my $mon = $dt_now->month(); # Текущий месяц
    my $mday = $dt_now->mday(); # Текущий день

    if($data[0]=~/сегодня в (\d{1,2}):(\d{1,2})/){
      $ret_data=$parser->parse_datetime("$year-$mon-$mday $1:$2");
    }elsif($data[0]=~/вчера в (\d{1,2}):(\d{1,2})/){
      $mday--;
      $ret_data=$parser->parse_datetime("$year-$mon-$mday $1:$2");
    } elsif ($data[0]=~/(\d{1,2}) (\w{1,}) (\d{4}) г. в (\d{1,2}):(\d{1,2})/) {
      my $month=month_num($2);
      $ret_data=$parser->parse_datetime("$3-$month-$1 $4:$5");
    }
    return $ret_data;
}

sub month_num {
    my $month_str = lc(shift);

    given ($month_str) {
        when (/янв/) {
            return 1;
        }
        when (/фев/) {
            return 2;
        }
        when (/мар/) {
            return 3;
        }
        when (/апр/) {
            return 4;
        }
        when (/май/) {
            return 5;
        }
        when (/мая/) {
            return 5;
        }
        when (/июн/) {
            return 6;
        }
        when (/июл/) {
            return 7;
        }
        when (/авг/) {
            return 8;
        }
        when (/сен/) {
            return 9;
        }
        when (/окт/) {
            return 10;
        }
        when (/ноя/) {
            return 11;
        }
        when (/дек/) {
            return 12;
        }
    }
    return 0;
}

sub make_eid {
    my ($id, $date) = @_;
    return $id . '_' . $date->strftime('%Y%m%d')
}

sub parse_adv {
    my ($dom, $data) = @_;

    unless ($data->{type_code}){
      my $head_ad = $dom->find('table[class="ob_header"]')->first->at('tr')->at('td')->next->at('h1')->text; #парсим заголовок объявления
      my $type_code= parse_type_realty ($head_ad);

      $data->{type_code} =$type_code;
    }
    if($data->{source_url} =~/\/(219|286|219)\//){
        $data->{rent_type}='short';
    }

    my $data_list=$dom->find('td[class="td1"]')->first->find('p'); #сохраняем список всех данных объявления

    my $list=0;
    #проверяем первую запись на наличие в ней стоимости
    unless($data_list->[0]->text){
        if($data_list->[0]->at('strong')->text =~/Стоимость: (\d{1,}) руб/){
          $data->{owner_price} = $1/1000 if $1 > 0;
          $list++;
        }
    }

    #перебор всех записей и извлечение данных
    do{

      #парсинг площади
      if ($data_list->[$list] =~/^<p>Общая площадь:/){
          if($data_list->[$list]->at('strong')->text =~ /(\d+) кв.м./){
              $data->{square_total} = $1 if $1 > 0;
          } elsif ($data_list->[$list]->at('strong')->text =~ /(\d+) (сот|га)/) {
              $data->{square_land} = $1 if $1 > 0;
              if ($2=~/сот/){
                 $data->{square_land_type} = 'ar';
              }
              else {
                 $data->{square_land_type} = 'hectare';
              }
          }
      }

      #парсинг количества комнат
      elsif ($data_list->[$list] =~/^<p>Кол-во комнат:/){
          $data->{rooms_count} =  0 + $data_list->[$list]->at('strong')->text;
      }

      #парсинг адреса (которое указано в соответствующем поле)
      elsif ($data_list->[$list] =~/^<p>Район, адрес:/){
          $data->{address} =  $data_list->[$list]->at('strong')->text;
      }

      #парсинг допп.ссылок
      elsif ($data_list->[$list] =~/^<p>Ссылка на описание:/){

      }
      #извлечение данных из текста объявления
      else {
        #если код объекта квартира и в тексте содержится  малосем
        if($data->{type_code} eq 'apartment' && $data_list->[$list] =~/малосемейк/){
            $data->{type_code} = 'apartment_small';
        }
        #определение этажности здания
        if ($data_list->[$list] =~ /.*(\s|,|\.)(\d{1,3}).{0,6}этаж(ей|ое|ного|ом)/){
            $data->{floors_count} = $2;
        }

        #определение этажа объекта
        if($data->{type_code} !~/(house)|(cottage)|(dacha)|(building)/){ #исключаем из поиска дома, коттеджы
          if ($data_list->[$list] =~ /.*(\s|,|\.)(\d{1,3}).{0,6}этаж(е|\W)/){
            $data->{floor} = $2;
          }
        }

        #определение типа здания
        $data->{house_type_id} = get_house_type($data_list->[$list]);

        #определение планировки комнат
        $data->{room_scheme_id} = get_room_type($data_list->[$list], $data);

        #определение текста объявления
        $data->{source_media_text} = $data_list->[$list];

        #определение балконов/лоджий
        $data->{balcony_id} = get_balcon_type($data_list->[$list]);

        #определение санузлов
        $data->{bathroom_id} = get_bathroom_type($data_list->[$list]);

        #определение состояния
        $data->{condition_id} = get_condition_type($data_list->[$list]);

        #определение планировка
        $data->{ap_scheme_id} = get_scheme_house($data_list->[$list]);
      }

      $list++;
    } while ($data_list->[$list] !~/^<p>Город:/);

    $data->{locality} =  $data_list->[$list]->at('strong')->text; #парсинг города (которое указано в соответствующем поле)

    get_phone_number($dom, $data); #парсинг данных автора сообщения (телефон)

    my $script = $dom->find('td[class="td1"]')->first->parent->at('td')->next->at('div')->at('script');
    my $dir;
    my @list;
    if($script){
      if($script =~/imagesDir = '(.+)';/){
          $dir = $1;
          if($script =~/imagesList = \['(.+)'\];/){
            @list=split(/', '/,$1);
          }
      }
      for(my $i=0; $i < scalar @list; ++$i){
        push @{$data->{photo_url}}, 'http://www.barahla.net/'.$dir.'big/'.$list[$i].'.jpg';
      }
    }
    return $data;
}

sub get_res {
    my ($url, $headers) = @_;

    my $res;
    my $code = 0; # код 200 - все хорошо
    my $retry = 15;

    #push @headers, 'Referer' => $referer if $referer;
    #push @headers, 'Accept' => $accept if $accept;
    while ($code != 200 && $retry > 0) {
        $retry -= 1;
        if ($retry < 5) {
            say 'retry left ' . $retry;
        }
        $res = $ua->get($url, {      #отправляем get запрос на сайт и получаем ответ
            'Host' => 'habarovsk.barahla.net',
            'Connection' => 'keep-alive',
            'Cache-Control' => 'max-age=0',
            'User-Agent' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36',
            'Accept-Encoding' => 'gzip,deflate,sdch',
            'Accept-Language' => 'ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4',
            @$headers,
        })->res;

        $code = $res->code unless $res->error; # кодуприсваиваем текущее значение полученного ответа, если не получен код ошибки
        #say $code;
        #say $res->error;
    }

    if ($retry == 0) { # если количество повторов 0
        undef $res; # то обнуляем переменную с ресурсами
    }

    return $res;
}

sub parse_type_realty {
    my $text = lc(shift);
    given ($text) {
        when (/квартир/) {
            if($text=~/новостр/){
              return 'apartment_new';
            } else{
              return 'apartment';
            }
        }
        when (/комнат/) {
            return 'room';
        }
        when (/малосемей/) {
            return 'apartment_small';
        }
        when (/коттедж/) {
            return 'cottage';
        }
        when (/дом/) {
            return 'house';
        }
        when (/дач/) {
            return 'dacha';
        }
        when (/гараж/) {
            return 'garage';
        }
        when (/нежило/) {
            return 'gpurpose_place';
        }
        when (/автосервис/) {
            return 'autoservice_place';
        }
        when (/(базу)|(склад)/) {
            return 'warehouse_place';
        }
        when (/(торгов)|(павильон)|(магазин)/) {
            return 'market_place';
        }
        when (/(офис)/) {
            return 'office_place';
        }
        when (/(здание)/) {
            return 'building';
        }
        when (/(многофункциональное)|(универсальное)/) {
            return 'service_place';
        }
        when (/(завод)|(цех)|(производств)/) {
            return 'production_place';
        }
        when (/(гостиниц)|(кафе)|(ресторан)|(салон)|(бизнес)/) {
            return 'other';
        }
        when (/хозяйств/) {
            return 'land';
        }
    }
    return 'other';
}

sub get_phone_number {
    my ($dom_old, $data) = @_;
    my $pnone_str;
    my @phones = ();

    eval{
      do{
        $dom_old = get_res($data->{source_url},[])->dom;
        my $text=$dom_old->find('table[class="author_ob"]')->first->at('tr')->next->at('td')->next->at('p')->next->next->at('span')->at('a');

        if($text->attr('onclick') =~ /key: '(\w+)'/){
            my $ua = Mojo::UserAgent->new;
            my $tx = $ua->post('http://habarovsk.barahla.net/ajax/getPhones.php?rand='.rand() => form => {key => $1, br => 'BR_TAG'},);
            $pnone_str = $tx->{res}->{content}->{asset}->{content};
          }
      } while($pnone_str=~/error/);
      if($pnone_str=~/<nobr>(.+)<.nobr>; (.+)/){
            push @phones, Rplus::Util::PhoneNum::parse($1, $app_config->{default_phone_prefix});
            push @phones, Rplus::Util::PhoneNum::parse($2, $app_config->{default_phone_prefix});
      } elsif ($pnone_str=~/<nobr>(.+)<.nobr>/) {
            push @phones, Rplus::Util::PhoneNum::parse($1, $app_config->{default_phone_prefix});
      } else {
            push @phones, Rplus::Util::PhoneNum::parse($pnone_str, $app_config->{default_phone_prefix});
      }
    } or do {

    };
    $data->{'owner_phones'} = \@phones;
}

sub get_house_type {
  my $text = lc(shift);
  given ($text) {
      when (/(кирпичн(.{1,4}) дом)|(дом.{1}кирпичн)/) {
        return 1;
      }
      when (/(монолитн(.{1,4}) дом)|(дом.{1}монолит)/) {
          return 2;
      }
      when (/(панельн(.{1,4}) дом)|(дом.{1}панельн)/) {
          return 3;
      }
      when (/(деревян(.{1,4}) дом)|(дом.{1}деревян)/) {
        return 5 if (/брус/);
        return 4;
      }
      when (/брус/) {
          return 5;
      }
      when (/(каркасно-засыпн(.{1,4}) дом)|(дом.{1}каркасно-засыпн)/) {
          return 6;
      }
      when (/(монолитно-кирпичн(.{1,4}) дом)|(дом.{1}монолитно-кирпичн)/) {
          return 7;
      }
  }
  return undef;
}

sub get_room_type {
  my ($text, $data) = @_;
  given ($text) {
      when ($data->{type_code}=~/(apartment)/ && /студия/) {
          return 1;
      }
      when (/кухня-костин/) {
          return 2;
      }
      when (/(раздельн(.{1,4})комнат)|(комнат.{1,3}раздельн)/) {
          return 3;
      }
      when (/(смежн(.{1,4})комнат)|(комнат.{1,3}смежн)/) {
          return 4;
      }
      when (/(смежно-раздельн(.{1,4})комнат)|(комнат.{1,3}смежно-раздельн)/) {
          return 4;
      }
      when (/икарус/) {
          return 5;
      }
  }
  return undef;
}

sub get_balcon_type {
  my $text = lc(shift);
  given ($text) {
      when (/балкон/ && /лоджи/) {
          return 4;
      }
      when (/лоджии/) {
          return 8;
      }
      when (/балкона/) {
          return 7;
      }
      when (/(лоджи. застеклен)|(застеклен.{0,4} лодж)/) {
          return 5;
      }
      when (/(балкон застеклен)|(застеклен.{0,4} балкон)/) {
          return 6;
      }
      when (/лоджия/) {
          return 3;
      }
      when (/балкон/) {
          return 2;
      }
  }
  return undef;
}

sub get_bathroom_type {
  my $text = lc(shift);
  given ($text) {
      when (/(сануз.{0,4} раздельн)|(раздельн.{0,6} сануз)/) {
        if ($text=~/санузла/){
          return 5;
        }
        else{
          return 3;
        }

      }
      when (/(сануз.{0,4} совмещ)|(совмещ.{0,6} сануз)/) {
          return 8;
      }
      when (/(сануз.{0,4} смежн)|(смежн.{0,6} сануз)/) {
          return 4;
      }
      when (/туалет/) {
        if($text=~/(душ)/){
          return 6;
        } else{
          return 7;
        }
      }
      when (/c удобств/) {
          return 9;
      }
  }
  return undef;
}

sub get_condition_type {
  my $text = lc(shift);
  given ($text) {
      when (/евро.{0,1}ремонт/) {
          return 4;
      }
      when (/соц.{0,8}ремонт/) {
          return 2;
      }
      when (/дизайнер.{0,5}ремонт/) {
          return 5;
      }
      when (/(уд.{0,17}состоян)|(состоян.{0,5} уд)/) {
          return 9;
      }
      when (/(норм.{0,7}состоян)|(состоян.{0,5} норм)/) {
          return 10;
      }
      when (/(хор.{0,6}состоян)|(состоян.{0,5} хор)/) {
          return 11;
      }
      when (/(отл.{0,7}состоян)|(состоян.{0,5} отл)/) {
          return 12;
      }
      when (/(требуется ремонт)/) {
          return 6;
      }
      when (/(требуется косм.{0,10} ремонт)/) {
          return 7;
      }
      when (/(после строит)/) {
          return 1;
      }
      when (/(ремонт)/) {
          return 3;
      }
  }
  return undef;
}

sub get_scheme_house {
  my $text = lc(shift);
  given ($text) {
      when (/хрущ/) {
          return 2;
      }
      when (/(брежнев)|(улучш.{0,6}планир)|(планир.{0,5}улучш)/) {
          return 3;
      }
      when (/сталин/) {
          return 1;
      }
      when (/(нов.{0,5}планир)|(планир.{0,5}новая)/) {
          return 4;
      }
      when (/(индивид.{0,7}планир)|планир.{0,5}индивид/) {
          return 5;
      }
      when (/общежит/) {
          return 6;
      }
  }
  return undef;
}
