#!/usr/bin/env perl

use FindBin;
use lib "$FindBin::Bin/../../../lib";

use Rplus::Modern;

use Rplus::Model::Media::Manager;
use Rplus::Model::MediaImportStatistic::Manager;
use Rplus::Model::MediaImportHistory::Manager;
use Rplus::Model::Realty::Manager;

use Rplus::Util::Config;
use Rplus::Util::PhoneNum;
use Rplus::Util::Realty qw(put_object);
use Rplus::Util::StatImport;
use Rplus::Util::Mediator qw(add_mediator);

use File::Basename;
use Text::Trim;
use JSON;
use Mojo::UserAgent;
use DateTime::Format::Strptime;

use File::Touch;
use Data::Dumper;

no warnings 'experimental';

my $app_config = Rplus::Util::Config::get_config();
my $config = Rplus::Util::Config::get_config('import.conf');
my $present_site_config = $config->{present_site};
my $main_url = $present_site_config->{main_url};

my $all_url_list = $present_site_config -> {source_list};

my $lock_file = '/var/tmp/present_s_lock';

my $MEDIA = Rplus::Model::Media::Manager->get_objects(query => [type => 'import', code => 'present_site', delete_date => undef])->[0];	# code => 'avito'

exit unless $MEDIA;

my $META = from_json($MEDIA->metadata);

my $ua = Mojo::UserAgent->new; # создание нового HTTP соединения
$ua->max_redirects(4); # максимальное кол0во перенаправлений

#$ua->proxy->http('http://185.5.250.133:19888');

my %date_map = ();
my $parser = DateTime::Format::Strptime->new( pattern => '%Y-%m-%d %H:%M' ); #Шаблон времени Год-месяц-день Часы:минуты
     #переменная для подсчета статистики
my $stat_count = { count_all_ad => 0,  #найдённых ссылок
                   count_new_ad => 0,   #новых объектов
                   count_update_ad => 0 ,  #обновленных объектов
                    count_update_link => 0 ,  #обновленных ссылок
                    count_error_ad => 0 ,   #кол-во ошибок
                    url_list => [], #ссылки с ошибками
                    error_list => [] #текст с ошибками};
};
say 'importing...';
unless (_import_in_progress()) { #Если импортирование не в процессе
    _lock();
    import_present_site ();
    _unlock();
}
say "End importing process";

sub _lock {
    my $temp=touch($lock_file); # создать файл
}

sub _unlock {
    unlink $lock_file; # удалить файл
}

sub _import_in_progress {
    $stat_count->{date_start} = DateTime->now(time_zone => "local");
    if (-e $lock_file) { #существует ли файл?
        my $mtime = ( stat $lock_file )[9]; #получение статуса о файле 9-время последнего изменения о файле
        my $current_time = time; #получение текущего времени
        my $diff = $current_time - $mtime; #вычисление разницы между текущим и временем изменения файла
        if ($diff < 6 * 60 * 60) { #если разница меньше 21600 секунд (6 часов)
            return 0; #возвращаем true
        }
    }
    #return 1 if -e $lock_file;
    return 0;
}

sub import_present_site {

    my @url_list;
    foreach (@$all_url_list){
        @url_list = get_url_list($main_url . $_->{url}, $_->{pages}); # наполняем массив списком URL
        process_url_list(\@url_list, $_->{type}, $_->{offer_type});
    }

    Rplus::Util::StatImport::save_import_statistic($MEDIA->id, $stat_count);
}

sub get_url_list {
    my ($main_page, $page_count) = @_; # получаем переданные в функцию значения
                                      # $main_page главная страница
                                      # $page_count количество страниц
    my @url_list;

    my $postfix = '?store-scope=all'; #не понятно что меняет на странице
    for(my $i = 1; $i <= $page_count; $i ++) { # перебор по страницам до $page_count страницы
        sleep 2;
        my $page = $main_page . '/page/' . $i . $postfix; # страница №i с объектами
        my $itms = get_res($page, [])->dom->find('div[class="notices"]')->first; #находим в ресурсах DOM страницы и
                                                          # находим блок div, извлекаем из него данные
        $itms->find('div[id="notice_top_list"] > div[class="items"] > div')->each (sub {

            my $item_url = $_->at('a')->{href};  #извлечение ссылки
            my $item_id = basename($item_url); #извлечение имени из ссылки

            # дата размещения
            my $date_str = $_->find('span[class="date"]')->first->text; #находим текст с данными о дате размещения
            my $dt = parse_date($date_str); #Приводим дату к единому формату по образцу парсера

            $date_map{$item_id} = $dt; #сохраняем дату в глоб.переменную используя ID-Data
            my $eid = make_eid($item_id, $dt); #создаём уник.ID в формате ID_DATA
            if (Rplus::Model::MediaImportHistory::Manager->get_objects_count(query => [media_id => $MEDIA->id, media_num => $eid])) {
                #say 'was processed already';

            } else {
                say $item_url;
                if ($item_url ~~ @url_list) { #Проверяет есть ли этот объект в массиве
                    say 'wtf?!';
                } else {
                    push(@url_list, $item_url); #сохраняем в массив URL ссылку
                }
            }
        });

        $itms->find('div[id="notice_list"] > div[class="items"] > div')->each (sub {
            my $item_url = $_->at('a')->{href};
            my $item_id = basename($item_url);

            # дата размещения
            my $date_str = $_->find('span[class="date"]')->first->text;
            my $dt = parse_date($date_str);
            $date_map{$item_id} = $dt;
            my $eid = make_eid($item_id, $dt);

            if (Rplus::Model::MediaImportHistory::Manager->get_objects_count(query => [media_id => $MEDIA->id, media_num => $eid])) {
                #say 'was processed already';
            } else {
                say $item_url;
                if ($item_url ~~ @url_list) {
                    say 'wtf?!';
                } else {
                    push(@url_list, $item_url);
                }
            }
        });
    }
    $stat_count->{count_all_ad}+=scalar @url_list;
    return reverse @url_list;  #reverse - переворачивает массив
}

sub process_url_list {
    my ($url_list_ref, $category_code, $offer_type, $rent_type) = @_;

    for my $item_url (@$url_list_ref){ # перебор всех значений в массиве

        my $page_url = $main_url . $item_url; # страница c объектом
        my $item_id = basename($page_url); # извлечение имени объекта из адреса
        my $dt = $date_map{$item_id};# извлесчение даты из хеш массива
        my $eid = make_eid($item_id, $dt);# создание уникального идентификатора
        say 'processing ' . $page_url;

        my $data = {
            source_media_id => $MEDIA->id,
            source_url => $page_url,
            type_code => $category_code,
            offer_type_code => $offer_type,
            rent_type => $rent_type,
            add_date => $dt->datetime() . '+10',  # fix it!
        };

        sleep 2;
        eval { # функция схожа с try-catch на JAva

            my $dom = get_res($page_url, [])->dom; #Изьятия Dom страницы объекта
            if ($dom) { #Если Dom не пустой
                eval { # попробовать выполнить
                    parse_adv($dom, $data);
                } or do {
                    say "ERROR of Parsing: ".$@;  # сообщение об ошибке
                }
            }

            my $id;
            {
                eval {
                    $id = Rplus::Util::Realty::put_object($data, $app_config, $stat_count);
                } or do {
                    say "Error of put object:".$@;
                }
            }
            # Сохраним историю
            if ($id && !Rplus::Model::MediaImportHistory::Manager->get_objects_count(query => [media_id => $MEDIA->id, media_num => $eid])) {
                Rplus::Model::MediaImportHistory->new(media_id => $MEDIA->id, media_num => $eid, media_text => $main_url . $item_url, realty_id => $id)->save;
            }

        } or do {
          if($@){
            say "Err:".$@;
          }
        }
    }
}

sub parse_adv {
    my ($dom, $data) = @_;

    #парсим текст объявления
    $data->{source_media_text} = $dom->find('div[class="notice-card"] div[class="text"]')->first->text;

    #найдём поля с данными о недвижимости
    $dom->find('div[class="notice-card"] div[class="fields"]')->first->children->each (sub {

      #извлечение цены
      if($_->at('strong')->text =~ /Цена:/){
          my $price = $_->at('span')->text;
          $price =~ s/\D//g;
          $data->{owner_price} = 0 + $price/1000 if $price > 0;
      }

      #извлечение арендной платы
      elsif ($_->at('strong')->text =~/Арендная плата/){
            $data->{owner_price} = 0 + $_->at('span')->text;
      }

      #определяем новостройку
      elsif($_->at('strong')->text =~ /Вторичный рынок:/){
          $data->{type_code} = 'apartment_new' if($_->at('span')->text =~ /да/i);
      }

      #парсинг адреса
      if($_->at('strong')->text =~ /Улица\/переулок:/){
          $data->{address}= $_->at('span')->text;
      }

      #парсинг города
      if($_->at('strong')->text =~ /Населенный пункт:/){
          $data->{locality}= $_->at('span')->text;
      }

      #парсинг количества комнат
      elsif ($_->at('strong')->text =~/Количество комнат:/){
          if($_->at('span')->text =~/2-уровневая/){
              $data->{levels_count} = 2;
          } else{
            $data->{rooms_count} =  0 + $_->at('span')->text;
          }
      }

      #парсинг количества комнат аренды
      elsif ($_->at('strong')->text =~/Объект аренды/){
        if($_->at('span')->text=~ /(\d).+комн/){
          $data->{rooms_count} =  0 + $1;
        }
        elsif($_->at('span')->text=~ /Малосем/){
          $data->{type_code} =  'apartment_small';
        }
      }

      #парсинг планировка
      elsif ($_->at('strong')->text =~/Планировка:/){
          $data->{ap_scheme_id} =  get_scheme_house($_->at('span')->text);
      }

      #парсинг этажа
      elsif ($_->at('strong')->text =~/Этаж:/){
          $data->{floor} = 0 + $_->at('span')->text if ($_->at('span')->text =~ /\d{1,3}/);
      }

      #парсинг этажности
      elsif ($_->at('strong')->text =~/Этажность/){
          $data->{floors_count} = 0 + $_->at('span')->text if ($_->at('span')->text =~ /\d{1,3}/);
      }

      #парсинг типа здания
      elsif ($_->at('strong')->text =~/Материал стен:/){
          $data->{house_type_id} = get_house_type ($_->at('span')->text);
      }

      #определение состояния
      elsif ($_->at('strong')->text =~/Состояние:/){
          $data->{condition_id} = get_condition_type($_->at('span')->text);
      }

      #парсинг общей площади
      elsif ($_->at('strong')->text =~/Площадь (общая)|(\(кв\. м\))/){
         my $sq =  $_->at('span')->text;
         if($_->at('span')->text =~ /\d{1,5}/){
           $sq=~s/,/\./;
           $data->{square_total} = 0 + $sq;
         }
      }

      #парсинг площади дома
      elsif ($_->at('strong')->text =~/Площадь дома/){
        my $sq =  $_->at('span')->text;
        if($_->at('span')->text =~ /\d{1,5}/){
          $sq=~s/,/\./;
          $data->{square_total} = 0 + $sq;
        }
      }

      #парсинг жилой площади
      elsif ($_->at('strong')->text =~/Площадь жилая/){
        my $sq =  $_->at('span')->text;
        if($_->at('span')->text =~ /\d{1,5}/){
          $sq=~s/,/\./;
          $data->{square_living} = 0 + $sq;
        }
      }

      #парсинг площади кухни
      elsif ($_->at('strong')->text =~/Площадь кухни/){
        my $sq =  $_->at('span')->text;
        if($_->at('span')->text =~ /\d{1,5}/){
          $sq=~s/,/\./;
          $data->{square_kitchen} = 0 + $sq;
        }
      }

      #парсинг участка
      elsif ($_->at('strong')->text =~/Площадь (участка)|(\(сотки\))/){
        my $sq =  $_->at('span')->text;
        if($_->at('span')->text =~ /\d{1,5}/){
          $sq=~s/,/\./;
          $data->{square_land} = 0 + $sq;
          $data->{square_land_type} = 'ar';
        }
      }

      #определение балконов/лоджий
      elsif ($_->at('strong')->text =~/Балкон\/лоджия/){
          $data->{balcony_id} = get_balcon_type($_->at('span')->text);
      }
    });

    #парсим телефон
    my $phone_text=$dom->find('div[class="notice-card"] div[class="phone"]')->first;
    my @phone=();
    if($phone_text){
        push @phone, Rplus::Util::PhoneNum::parse($phone_text->text, $app_config->{default_phone_prefix});
    }
    $data->{owner_phones}=\@phone;

	  my $do = $dom->find('div[class="lightbox images"]');
	  $do->first->find('a[target="_blank"]')->each ( sub {
		    my $img_url = $main_url . $_->{'href'};
		      push @{$data->{photo_url}}, $img_url;
	});

    return $data;
};

sub get_res {
    my ($url, $headers) = @_;

    my $res;
    my $code = 0; # код 200 - все хорошо
    my $retry = 15;

    #push @headers, 'Referer' => $referer if $referer;
    #push @headers, 'Accept' => $accept if $accept;
    while ($code != 200 && $retry > 0) {
        $retry -= 1;
        if ($retry < 5) {
            say 'retry left ' . $retry;
        }
        $res = $ua->get($url, {      #отправляем get запрос на сайт и получаем ответ
            'Host' => 'present-dv.ru',
            'Connection' => 'keep-alive',
            'Cache-Control' => 'max-age=0',
            'User-Agent' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36',
            'Accept-Encoding' => 'gzip,deflate,sdch',
            'Accept-Language' => 'ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4',
            @$headers,
        })->res;

        $code = $res->code unless $res->error; # кодуприсваиваем текущее значение полученного ответа, если не получен код ошибки
        #say $code;
        #say $res->error;
    }

    if ($retry == 0) { # если количество повторов 0
        undef $res; # то обнуляем переменную с ресурсами
    }

    return $res;
}

sub make_eid {
    my ($id, $date) = @_;
    return $id . '_' . $date->strftime('%Y%m%d')
}

sub parse_date {
    my $date = lc(shift);
    my $res;
    my $dt_now = DateTime->now(time_zone => "+1000"); # сохраняем текущее время с учетом временной зоны +10 (Хабаровск)

    my $year = $dt_now->year(); # Текущий год
    my $mon = $dt_now->month(); # Текущий месяц
    my $mday = $dt_now->mday(); # Текущий день

    if ($date =~ /(\d{1,2}):(\d{1,2})/) { # Если Дата содержит  "цифра:цифра или цифрацифра:цифрацифра"
        $res = $parser->parse_datetime("$year-$mon-$mday $1:$2");

    } elsif ($date =~ /вчера/) { # иначе Если Дата содержит  вчера
        $res = $parser->parse_datetime("$year-$mon-$mday 12:00");
        $res->subtract(days => 1);
    } elsif ($date =~ /(\d{1,2}) (.+)/) { # иначе Если Дата содержит  "Цифра последоватльностьБукв"
        my $a_mon = month_num($2);
        $res = $parser->parse_datetime("$year-$a_mon-$1 12:00");
    }

    if ($res > $dt_now) {
        # substr 1 day
        $res->subtract(days => 1);
    }

    return $res;
}

sub month_num {
    my $month_str = lc(shift);

    given ($month_str) {
        when (/янв/) {
            return 1;
        }
        when (/фев/) {
            return 2;
        }
        when (/мар/) {
            return 3;
        }
        when (/апр/) {
            return 4;
        }
        when (/май/) {
            return 5;
        }
        when (/мая/) {
            return 5;
        }
        when (/июн/) {
            return 6;
        }
        when (/июл/) {
            return 7;
        }
        when (/авг/) {
            return 8;
        }
        when (/сен/) {
            return 9;
        }
        when (/окт/) {
            return 10;
        }
        when (/ноя/) {
            return 11;
        }
        when (/дек/) {
            return 12;
        }
    }
    return 0;
}

sub parse_type_realty {
    my $text = lc(shift);
    my $type;
    my $sub_type;
    if($text=~/.+estate=(\d)&purpose=(\d{0,2}).+/){
        $type=$1;
        $sub_type=$2;
    }
    return 'land' if($type==1);
    return 'apartment' if($type==2);
    return 'room' if($type==3);
    return 'garage' if($type==4);
    return 'house' if($type==5);
    if($type==6){
      return 'market_place' if($sub_type==1);
      return 'gpurpose_place' if($sub_type==2 || $sub_type==3 || $sub_type==7);
      return 'office_place' if($sub_type==4);
      return 'warehouse_place' if($sub_type==5 || $sub_type==6);
      return 'production_place' if($sub_type==8);
    }
    return undef;
}

sub get_house_type {
  my $text = lc(shift);
  given ($text) {
      when (/монолитно-кирпич/) {
        return 7;
      }
      when (/монолит/) {
          return 2;
      }
      when (/кирпич/) {
        return 1;
      }
      when (/панель/) {
          return 3;
      }
      when (/дерев/) {
          return 4;
      }
      when (/брус/) {
          return 5;
      }
  }
  return undef;
}

sub get_room_type {
  my $text = shift;
  given ($text) {
      when (/смеж(.+)раздельн/) {
          return 6;
      }
      when (/смежн/) {
          return 4;
      }
      when (/раздельн/) {
          return 3;
      }
      when (/студ/) {
          return 1;
      }
      when (/икарус/) {
          return 5;
      }
  }
  return undef;
}

sub get_balcon_type {
  my $text = lc(shift);
  given ($text) {
      when (/балкон \+ лоджия/) {
        return 4;
      }
      when (/лоджия/) {
          return 3;
      }
      when (/балкон/) {
          return 2;
      }
      when (/без/) {
          return 1;
      }
  }
  return undef;
}

sub get_condition_type {
  my $text = lc(shift);
  given ($text) {
      when (/евроремонт/) {
          return 4;
      }
      when (/удовлетворит/) {
          return 9;
      }
      when (/хорошее/) {
          return 11;
      }
      when (/отличное/) {
          return 12;
      }
      when (/(требуется капитальный ремонт)/) {
          return 6;
      }
      when (/(требуется косметический ремонт)/) {
          return 7;
      }
      when (/(после строителей)/) {
          return 1;
      }
      when (/(социальный)/) {
          return 2;
      }
  }
  return undef;
}

sub get_scheme_house {
  my $text = lc(shift);
  given ($text) {
      when (/хрущевка/) {
          return 2;
      }
      when (/брежневка/ || /улучшен/) {
          return 3;
      }
      when (/сталинка/) {
          return 1;
      }
      when (/новая/) {
          return 4;
      }
      when (/индивид/) {
          return 5;
      }
  }
  return undef;
}
