#!/usr/bin/env perl

use FindBin;
use lib "$FindBin::Bin/../lib";

use Rplus::Modern;
use Rplus::DB;

use Mojo::Asset::File;
use JSON;
use Data::Dumper;

$Data::Dumper::Terse = 1;        # don't output names where feasible
$Data::Dumper::Quotekeys = 0;

my $dbh = Rplus::DB->new_or_cached->dbh;

if (1) {

    say 'updating DB';

    $dbh->do(q{INSERT INTO "public"."dict_task_types" VALUES ('9', 'Назначен объект', '2014-08-28 21:50:26.213206+11', null, 'both', '#fbd75b');});
    $dbh->do(q{INSERT INTO "public"."dict_task_types" VALUES ('10', 'Спрос', '2014-08-28 21:50:26.213206+11', null, 'both', '#a4bdfc');});

    # Update model
    $dbh->do(q{ALTER TABLE public.users ADD COLUMN google JSON NOT NULL DEFAULT '{}'::json;});
    $dbh->do(q{ALTER TABLE public.users ADD COLUMN sync_google varchar NOT NULL DEFAULT 'ask'::character varying COLLATE "default";});

    #-- ----------------------------
    #--  Table structure for tasks
    #-- ----------------------------
    $dbh->do(q{DROP TABLE IF EXISTS "public"."tasks";});

    $dbh->do(q{CREATE TABLE "public"."tasks" (
        "id" serial NOT NULL,
        "task_type_id" int4 NOT NULL,
        "creator_user_id" int4 NOT NULL,
        "assigned_user_id" int4,
        "add_date" timestamp(6) WITH TIME ZONE NOT NULL DEFAULT now(),
        "remind_date" timestamp(6) WITH TIME ZONE,
        "start_date" timestamp(6) WITH TIME ZONE NOT NULL,
        "description" varchar COLLATE "default",
        "metadata" json NOT NULL DEFAULT '{}'::json,
        "delete_date" timestamp(6) WITH TIME ZONE,
        "status" varchar NOT NULL DEFAULT 'new'::character varying COLLATE "default",
        "change_date" timestamp(6) WITH TIME ZONE NOT NULL DEFAULT now(),
        "chaged_by_user_id" int4,
        "client_id" int4,
        "realty_id" int4,
        "google_id" varchar COLLATE "default",
        "end_date" timestamp(6) WITH TIME ZONE,
        "summary" varchar COLLATE "default"
    );});

    #-- ----------------------------
    #--  Primary key structure for table tasks
    #-- ----------------------------
    $dbh->do(q{ALTER TABLE "public"."tasks" ADD PRIMARY KEY ("id") NOT DEFERRABLE INITIALLY IMMEDIATE;});

    #-- ----------------------------
    #--  Indexes structure for table tasks
    #-- ----------------------------
    $dbh->do(q{CREATE INDEX  "task_type_id_idx" ON "public"."tasks" USING btree(task_type_id ASC NULLS LAST);});

    #-- ----------------------------
    #--  Foreign keys structure for table tasks
    #-- ----------------------------
    $dbh->do(q{ALTER TABLE "public"."tasks" ADD CONSTRAINT "task_type_fk" FOREIGN KEY ("task_type_id") REFERENCES "public"."dict_task_types" ("id") ON UPDATE NO ACTION ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;});
    $dbh->do(q{ALTER TABLE "public"."tasks" ADD CONSTRAINT "creator_user_fk" FOREIGN KEY ("creator_user_id") REFERENCES "public"."users" ("id") ON UPDATE NO ACTION ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;});
    $dbh->do(q{ALTER TABLE "public"."tasks" ADD CONSTRAINT "assigned_user_fk" FOREIGN KEY ("assigned_user_id") REFERENCES "public"."users" ("id") ON UPDATE NO ACTION ON DELETE NO ACTION NOT DEFERRABLE INITIALLY IMMEDIATE;});

    say 'updating config';

    my $config_path = "$FindBin::Bin/../app.conf";
    my $config = read_config($config_path);
    #print Dumper $config;
    $config->{roles}->{manager}->{clients} = {
            read => {others => 1, nobody => 1},
            write => 1,
            subscribe => 1,
        },
    $config->{roles}->{agent}->{dispatcher} = {
            read => {others => 1, nobody => 1},
            write => 1,
            subscribe => 1,
        },
    $config->{roles}->{agent}->{clients} = {
            read => {others => 0, nobody => 0},
            write => 0,
        },
    $config->{roles}->{agent_ext}->{clients} = {
            read => {others => 0, nobody => 1},
            write => 0,
        },
    #print Dumper $config;
    write_config($config, $config_path);

    say 'done';
}

sub read_config {
    my $file_name = shift;

    my $file = Mojo::Asset::File->new(path => $file_name);
    my $config = eval $file->slurp;
    return $config;
}

sub write_config {
    my $config = shift;
    my $file_name = shift;

    open OUTFILE, ">$file_name" or die "Can't open '$file_name':$!";

    print OUTFILE Dumper $config;
}

exit 1;
